# app/routers/resume_router.py
from fastapi import APIRouter, Depends, HTTPException, status, Body
from typing import List, Optional
from motor.motor_asyncio import AsyncIOMotorDatabase
from datetime import datetime
import traceback # For detailed error logging

from app.models import resume_models, user_models
from app.core import security
from app.db.mongodb_utils import get_database
# from bson import ObjectId # Not strictly needed if IDs are stored/handled as strings by default

router = APIRouter()

# --- Resume Database Operation Helper Functions ---
async def create_db_resume(db: AsyncIOMotorDatabase, resume_in: resume_models.ResumeCreate, user_id: str) -> resume_models.ResumeInDB:
    now = datetime.utcnow()
    # Pydantic V2: Use model_dump()
    resume_data_dict = resume_in.resume_data.model_dump()

    resume_db_obj = resume_models.ResumeInDB(
        resume_name=resume_in.resume_name,
        resume_data=resume_data_dict, # Store the complete resume_data object
        user_id=user_id,
        created_at=now,
        updated_at=now
        # id will be generated by default_factory in ResumeInDB if not provided,
        # and MongoDB will use its own _id upon insertion.
        # The model's 'id' field is aliased to '_id' for DB interaction.
    )
    # Pydantic V2: Use model_dump()
    # by_alias=True ensures that the field 'id' is dumped as '_id' for MongoDB insertion.
    resume_db_dict_for_insertion = resume_db_obj.model_dump(by_alias=True)

    result = await db["resumes"].insert_one(resume_db_dict_for_insertion)
    # Fetch the created document using the inserted_id from MongoDB, which will be an ObjectId
    # The ResumeInDB model will then map this _id (ObjectId or string representation) to its 'id' field (string).
    created_resume_from_db = await db["resumes"].find_one({"_id": result.inserted_id})

    if created_resume_from_db:
        # When creating ResumeInDB from DB data, Pydantic will use the '_id' from DB
        # to populate the 'id' field of the model, thanks to populate_by_name and alias.
        return resume_models.ResumeInDB(**created_resume_from_db)
    raise HTTPException(status_code=500, detail="Could not create resume in database.")

async def get_db_resume_by_id(db: AsyncIOMotorDatabase, resume_id: str, user_id: str) -> Optional[resume_models.ResumeInDB]:
    # Assuming resume_id is the string representation of MongoDB's ObjectId
    # If your resume_id in the path is directly the string form of _id, this is fine.
    # If it's another custom ID, adjust the query.
    # For MongoDB, if 'id' in your model is aliased to '_id', queries against '_id' are typical.
    resume_dict = await db["resumes"].find_one({"_id": resume_id, "user_id": user_id})
    if resume_dict:
        return resume_models.ResumeInDB(**resume_dict)
    return None

async def get_db_resumes_by_user_id(db: AsyncIOMotorDatabase, user_id: str) -> List[resume_models.ResumeInDB]:
    resumes = []
    print(f"DEBUG: Fetching resumes for user_id: {user_id}") # Debug log
    cursor = db["resumes"].find({"user_id": user_id})
    count = 0
    async for resume_dict_from_db in cursor:
        count += 1
        print(f"--- DEBUG: Item {count} ---") # Debug log
        print(f"Raw resume_dict from DB: {resume_dict_from_db}") # Debug log

        # Check the type of _id from DB
        db_doc_id = resume_dict_from_db.get("_id")
        print(f"DB document _id: {db_doc_id}, type: {type(db_doc_id)}") # Debug log

        try:
            # Pydantic V2 will attempt to convert _id (e.g., ObjectId) to str for the 'id' field.
            instance = resume_models.ResumeInDB(**resume_dict_from_db)
            print(f"Pydantic instance.id after init: {instance.id}, type: {type(instance.id)}") # Debug log
            print(f"Pydantic instance.resume_name: {instance.resume_name}") # Debug log
            
            # Use model_dump() for Pydantic V2
            serialized_data = instance.model_dump() # by_alias=False by default, so 'id' will be 'id'
            print(f"Serialized instance (V2 .model_dump()): {serialized_data}") # Debug log
            
            if 'id' not in serialized_data:
                print(f"CRITICAL DEBUG: 'id' field is MISSING from model_dump for DB _id {db_doc_id}") # Debug log
            elif serialized_data.get('id') is None:
                 print(f"CRITICAL DEBUG: 'id' field is None in model_dump for DB _id {db_doc_id}") # Debug log
            elif not isinstance(serialized_data.get('id'), str):
                 print(f"CRITICAL DEBUG: 'id' field is NOT A STRING in model_dump for DB _id {db_doc_id}, type: {type(serialized_data.get('id'))}")

            resumes.append(instance)
        except Exception as e:
            print(f"ERROR DEBUG: Error creating Pydantic instance for DB _id {db_doc_id}: {e}") # Debug log
            traceback.print_exc() # Print full traceback for the error
    print(f"DEBUG: Total resumes processed for user {user_id}: {count}") # Debug log
    return resumes


async def update_db_resume(db: AsyncIOMotorDatabase, resume_id: str, resume_update: resume_models.ResumeUpdate, user_id: str) -> Optional[resume_models.ResumeInDB]:
    existing_resume = await get_db_resume_by_id(db, resume_id, user_id)
    if not existing_resume:
        return None

    update_data = {}
    # Pydantic V2: Use model_dump with exclude_unset=True to get only provided fields
    update_payload = resume_update.model_dump(exclude_unset=True)

    if "resume_name" in update_payload:
        update_data["resume_name"] = update_payload["resume_name"]
    if "resume_data" in update_payload: # resume_data itself is a model
        update_data["resume_data"] = update_payload["resume_data"] # Already a dict from model_dump
    
    if not update_data: # If no updatable fields were provided in the payload
        return existing_resume

    update_data["updated_at"] = datetime.utcnow()

    result = await db["resumes"].update_one(
        {"_id": resume_id, "user_id": user_id}, # Query by MongoDB's _id
        {"$set": update_data}
    )
    if result.modified_count == 1:
        updated_resume_from_db = await get_db_resume_by_id(db, resume_id, user_id)
        return updated_resume_from_db
    # If no modification (e.g., data provided was same as existing), or update failed to match
    # Return the existing (potentially unchanged) resume or None if it disappeared (edge case)
    return await get_db_resume_by_id(db, resume_id, user_id)


async def delete_db_resume(db: AsyncIOMotorDatabase, resume_id: str, user_id: str) -> bool:
    result = await db["resumes"].delete_one({"_id": resume_id, "user_id": user_id}) # Query by MongoDB's _id
    return result.deleted_count > 0


# --- API Endpoints ---
@router.post("/", response_model=resume_models.Resume, status_code=status.HTTP_201_CREATED)
async def create_resume_endpoint( # Renamed to avoid conflict with helper
    resume_in: resume_models.ResumeCreate,
    db: AsyncIOMotorDatabase = Depends(get_database),
    current_user: user_models.User = Depends(security.get_current_active_user)
):
    """
    Create a new resume for the currently authenticated user.
    """
    # The user_id from current_user should be a string (e.g. UUID string)
    created_resume = await create_db_resume(db, resume_in, user_id=str(current_user.id))
    # `created_resume` is a ResumeInDB instance. FastAPI will serialize it using Resume model.
    # The 'id' field (from _id) should be correctly populated.
    return created_resume

@router.get("/", response_model=List[resume_models.Resume])
async def read_resumes_endpoint( # Renamed
    db: AsyncIOMotorDatabase = Depends(get_database),
    current_user: user_models.User = Depends(security.get_current_active_user),
    skip: int = 0,
    limit: int = 100
):
    """
    Get all resumes for the currently authenticated user.
    """
    # Ensure current_user.id is string for comparison if user_id in DB is string
    user_id_str = str(current_user.id)
    all_user_resumes = await get_db_resumes_by_user_id(db, user_id=user_id_str)
    # Manual pagination (can be optimized with .skip().limit() in the DB query itself if performance is critical)
    return all_user_resumes[skip : skip + limit]


@router.get("/{resume_id}", response_model=resume_models.Resume)
async def read_resume_endpoint( # Renamed
    resume_id: str, # This resume_id from path should be the string representation of the DB _id
    db: AsyncIOMotorDatabase = Depends(get_database),
    current_user: user_models.User = Depends(security.get_current_active_user)
):
    """
    Get a specific resume by its ID. User can only access their own resumes.
    """
    user_id_str = str(current_user.id)
    resume = await get_db_resume_by_id(db, resume_id, user_id=user_id_str)
    if resume is None:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Resume not found or access denied")
    return resume

@router.put("/{resume_id}", response_model=resume_models.Resume)
async def update_resume_endpoint( # Renamed
    resume_id: str,
    resume_update: resume_models.ResumeUpdate,
    db: AsyncIOMotorDatabase = Depends(get_database),
    current_user: user_models.User = Depends(security.get_current_active_user)
):
    """
    Update a specific resume by its ID. User can only update their own resumes.
    """
    user_id_str = str(current_user.id)
    updated_resume = await update_db_resume(db, resume_id, resume_update, user_id=user_id_str)
    if updated_resume is None:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Resume not found or update failed")
    return updated_resume

@router.delete("/{resume_id}", status_code=status.HTTP_204_NO_CONTENT)
async def delete_resume_endpoint( # Renamed
    resume_id: str,
    db: AsyncIOMotorDatabase = Depends(get_database),
    current_user: user_models.User = Depends(security.get_current_active_user)
):
    """
    Delete a specific resume by its ID. User can only delete their own resumes.
    """
    user_id_str = str(current_user.id)
    deleted = await delete_db_resume(db, resume_id, user_id=user_id_str)
    if not deleted:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Resume not found for deletion")
    return # Returns 204 No Content
